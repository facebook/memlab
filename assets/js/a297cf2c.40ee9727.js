"use strict";(self.webpackChunkmemlab_website=self.webpackChunkmemlab_website||[]).push([[9004],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>c});var a=t(6540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach(function(n){r(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),m=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=m(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},y=a.forwardRef(function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=m(t),y=r,c=p["".concat(s,".").concat(y)]||p[y]||d[y]||l;return t?a.createElement(c,o(o({ref:n},u),{},{components:t})):a.createElement(c,o({ref:n},u))});function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,o=new Array(l);o[0]=y;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[p]="string"==typeof e?e:r,o[1]=i;for(var m=2;m<l;m++)o[m]=t[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}y.displayName="MDXCreateElement"},9102:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>m});var a=t(8168),r=(t(6540),t(5680));const l={id:"visually-debug-memory-leaks-with-memlens"},o="Visual Debugging for Memory Leaks",i={unversionedId:"guides/visually-debug-memory-leaks-with-memlens",id:"guides/visually-debug-memory-leaks-with-memlens",title:"Visual Debugging for Memory Leaks",description:"Memory Lens (MemLens) is a utility tool that helps visually debug memory leaks",source:"@site/docs/guides/06-visually-debug-leaks-with-memlens.mdx",sourceDirName:"guides",slug:"/guides/visually-debug-memory-leaks-with-memlens",permalink:"/memlab/docs/guides/visually-debug-memory-leaks-with-memlens",draft:!1,editUrl:"https://github.com/facebook/memlab/blob/main/website/docs/guides/06-visually-debug-leaks-with-memlens.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"visually-debug-memory-leaks-with-memlens"},sidebar:"sidebar",previous:{title:"Integrate with Test Frameworks",permalink:"/memlab/docs/guides/integrate-with-e2e-frameworks"},next:{title:"How memlab Works",permalink:"/memlab/docs/how-memlab-works"}},s={},m=[{value:"Manually Running MemLens in a Browser",id:"manually-running-memlens-in-a-browser",level:2},{value:"Using MemLens with MemLab",id:"using-memlens-with-memlab",level:2}],u={toc:m},p="wrapper";function d({components:e,...n}){return(0,r.yg)(p,(0,a.A)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"visual-debugging-for-memory-leaks"},"Visual Debugging for Memory Leaks"),(0,r.yg)("p",null,"Memory Lens (MemLens) is a utility tool that helps visually debug memory leaks\nin web browsers. It highlights detached DOM elements still retained in memory\nand leaking React components with an overlay,\nallowing you to identify leaked elements right after interactions and\ntrace their retainer paths in the browser\u2019s DevTools using memory IDs\nannotated by MemLens."),(0,r.yg)("p",null,"You can use MemLens in two ways:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Manually copy and paste MemLens\u2019 code into the browser console\nto debug leaks in the current page."),(0,r.yg)("li",{parentName:"ol"},"Run MemLens through MemLab.")),(0,r.yg)("p",null,"The sections below explain how to use MemLens for browser memory leak debugging."),(0,r.yg)("h2",{id:"manually-running-memlens-in-a-browser"},"Manually Running MemLens in a Browser"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Copy and paste the ",(0,r.yg)("a",{parentName:"li",href:"https://github.com/facebook/memlab/tree/main/packages/lens/dist/memlens.run.bundle.min.js"},"MemLens bundle code"),"\ninto your browser\u2019s console (close DevTools to avoid leaks caused by\nChrome DevTools)."),(0,r.yg)("li",{parentName:"ol"},"Interact with the page without triggering a full refresh, as a hard\nrefresh clears the entire JS heap and makes leak debugging unnecessary."),(0,r.yg)("li",{parentName:"ol"},"When MemLens outlines possible memory leaks, take a heap snapshot and\nsearch for the displayed memory IDs.")),(0,r.yg)("p",null,"To build the bundle yourself, clone the\n",(0,r.yg)("a",{parentName:"p",href:"https://github.com/facebook/memlab"},"MemLab repository"),",\nrun ",(0,r.yg)("inlineCode",{parentName:"p"},"npm run build"),", and copy the MemLens bundle code from\n",(0,r.yg)("inlineCode",{parentName:"p"},"packages/lens/dist/memlens.run.bundle.min.js")," or\n",(0,r.yg)("inlineCode",{parentName:"p"},"packages/lens/dist/memlens.run.bundle.js"),"."),(0,r.yg)("p",null,"The screen recording below demonstrates how to use MemLens on a web page."),(0,r.yg)("div",{style:{position:"relative",paddingBottom:"56.25%",height:0,overflow:"hidden",maxWidth:"100%"}},(0,r.yg)("iframe",{src:"https://player.vimeo.com/video/1110113648?title=0&byline=0&portrait=0",style:{position:"absolute",top:0,left:0,width:"100%",height:"100%"},frameBorder:"0",allow:"autoplay; fullscreen; picture-in-picture",allowFullScreen:!0})),(0,r.yg)("p",null,"Once MemLens is active, it tracks React components that leak DOM elements and\noutlines them on the page. Each outline includes a memory ID. Hover over the\noutline to view the memory ID and the corresponding React component stack,\nor click to pin it."),(0,r.yg)("p",null,"With the memory ID, take a heap snapshot in Chrome DevTools and search for\nit in the Memory panel. This will reveal the leaked component\u2019s retained\npath in the JS heap, helping you understand why it remains in memory."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Note:")," The target page should ideally be a React app serving minified\nJS code. When searching for the memory ID in Chrome DevTools, the detached\nDOM element\u2019s retainer path will also appear minified."),(0,r.yg)("h2",{id:"using-memlens-with-memlab"},"Using MemLens with MemLab"),(0,r.yg)("p",null,"MemLens can also run during MemLab executions in headful mode to display\nleak outlines:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"memlab run --scenario your_test_scenario_file_path.js --headful --display-leak-outlines\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"--headful"),": Runs the browser in visible mode so you can see the UI."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"--display-leak-outlines"),": Enables MemLens to track and display outlines\nof leaked components in the test page.")),(0,r.yg)("p",null,"If you want to pause a MemLab run at steps defined in your scenario file\nand interact with MemLens in the headful browser session, use the ",(0,r.yg)("inlineCode",{parentName:"p"},"--debug"),"\noption. This pauses automated browser actions before each step until you\npress ",(0,r.yg)("strong",{parentName:"p"},"Enter")," in the terminal."))}d.isMDXComponent=!0}}]);