"use strict";(self.webpackChunkmemlab_website=self.webpackChunkmemlab_website||[]).push([[5112],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(a),k=r,u=c["".concat(p,".").concat(k)]||c[k]||m[k]||i;return a?n.createElement(u,o(o({ref:t},d),{},{components:a})):n.createElement(u,o({ref:t},d))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=k;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},6434:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const i={id:"core_src.IHeapNode",title:"Interface: IHeapNode",sidebar_label:"IHeapNode",custom_edit_url:null},o=void 0,l={unversionedId:"api/interfaces/core_src.IHeapNode",id:"api/interfaces/core_src.IHeapNode",title:"Interface: IHeapNode",description:"An IHeapNode instance represents a JS heap object in a heap snapshot.",source:"@site/docs/api/interfaces/core_src.IHeapNode.md",sourceDirName:"api/interfaces",slug:"/api/interfaces/core_src.IHeapNode",permalink:"/memlab/docs/api/interfaces/core_src.IHeapNode",draft:!1,editUrl:null,tags:[],version:"current",frontMatter:{id:"core_src.IHeapNode",title:"Interface: IHeapNode",sidebar_label:"IHeapNode",custom_edit_url:null},sidebar:"sidebar",previous:{title:"IHeapLocation",permalink:"/memlab/docs/api/interfaces/core_src.IHeapLocation"},next:{title:"IHeapNodes",permalink:"/memlab/docs/api/interfaces/core_src.IHeapNodes"}},p={},s=[{value:"Hierarchy",id:"hierarchy",level:2},{value:"Properties",id:"properties",level:2},{value:'<a id="dominatornode" name="dominatornode"></a> <strong>dominatorNode</strong>: <code>Nullable</code>&lt;<code>IHeapNode</code>&gt;',id:"-dominatornode-nullableiheapnode",level:3},{value:'<a id="edge_count" name="edge_count"></a> <strong>edge_count</strong>: <code>number</code>',id:"-edge_count-number",level:3},{value:'<a id="haspathedge" name="haspathedge"></a> <strong>hasPathEdge</strong>: <code>boolean</code>',id:"-haspathedge-boolean",level:3},{value:'<a id="id" name="id"></a> <strong>id</strong>: <code>number</code>',id:"-id-number",level:3},{value:'<a id="isstring" name="isstring"></a> <strong>isString</strong>: <code>boolean</code>',id:"-isstring-boolean",level:3},{value:'<a id="is_detached" name="is_detached"></a> <strong>is_detached</strong>: <code>boolean</code>',id:"-is_detached-boolean",level:3},{value:'<a id="location" name="location"></a> <strong>location</strong>: <code>Nullable</code>&lt;<code>IHeapLocation</code>&gt;',id:"-location-nullableiheaplocation",level:3},{value:'<a id="name" name="name"></a> <strong>name</strong>: <code>string</code>',id:"-name-string",level:3},{value:'<a id="nodeindex" name="nodeindex"></a> <strong>nodeIndex</strong>: <code>number</code>',id:"-nodeindex-number",level:3},{value:'<a id="numofreferrers" name="numofreferrers"></a> <strong>numOfReferrers</strong>: <code>number</code>',id:"-numofreferrers-number",level:3},{value:'<a id="pathedge" name="pathedge"></a> <strong>pathEdge</strong>: <code>null</code> | <code>IHeapEdge</code>',id:"-pathedge-null--iheapedge",level:3},{value:'<a id="references" name="references"></a> <strong>references</strong>: <code>IHeapEdge</code>[]',id:"-references-iheapedge",level:3},{value:'<a id="referrers" name="referrers"></a> <strong>referrers</strong>: <code>IHeapEdge</code>[]',id:"-referrers-iheapedge",level:3},{value:'<a id="retainedsize" name="retainedsize"></a> <strong>retainedSize</strong>: <code>number</code>',id:"-retainedsize-number",level:3},{value:'<a id="self_size" name="self_size"></a> <strong>self_size</strong>: <code>number</code>',id:"-self_size-number",level:3},{value:'<a id="snapshot" name="snapshot"></a> <strong>snapshot</strong>: <code>IHeapSnapshot</code>',id:"-snapshot-iheapsnapshot",level:3},{value:'<a id="type" name="type"></a> <strong>type</strong>: <code>string</code>',id:"-type-string",level:3},{value:"Methods",id:"methods",level:2},{value:'<a id="findanyreference"></a><strong>findAnyReference</strong>(<code>predicate</code>)',id:"findanyreferencepredicate",level:3},{value:'<a id="findanyreferrer"></a><strong>findAnyReferrer</strong>(<code>predicate</code>)',id:"findanyreferrerpredicate",level:3},{value:'<a id="findanyreferrernode"></a><strong>findAnyReferrerNode</strong>(<code>predicate</code>)',id:"findanyreferrernodepredicate",level:3},{value:'<a id="findreferrernodes"></a><strong>findReferrerNodes</strong>(<code>predicate</code>)',id:"findreferrernodespredicate",level:3},{value:'<a id="findreferrers"></a><strong>findReferrers</strong>(<code>predicate</code>)',id:"findreferrerspredicate",level:3},{value:'<a id="foreachreference"></a><strong>forEachReference</strong>(<code>callback</code>)',id:"foreachreferencecallback",level:3},{value:'<a id="foreachreferrer"></a><strong>forEachReferrer</strong>(<code>callback</code>)',id:"foreachreferrercallback",level:3},{value:'<a id="getanyreferrer"></a><strong>getAnyReferrer</strong>(<code>edgeName</code>, <code>edgeType?</code>)',id:"getanyreferreredgename-edgetype",level:3},{value:'<a id="getanyreferrernode"></a><strong>getAnyReferrerNode</strong>(<code>edgeName</code>, <code>edgeType?</code>)',id:"getanyreferrernodeedgename-edgetype",level:3},{value:'<a id="getreference"></a><strong>getReference</strong>(<code>edgeName</code>, <code>edgeType?</code>)',id:"getreferenceedgename-edgetype",level:3},{value:'<a id="getreferencenode"></a><strong>getReferenceNode</strong>(<code>edgeName</code>, <code>edgeType?</code>)',id:"getreferencenodeedgename-edgetype",level:3},{value:'<a id="getreferrernodes"></a><strong>getReferrerNodes</strong>(<code>edgeName</code>, <code>edgeType?</code>)',id:"getreferrernodesedgename-edgetype",level:3},{value:'<a id="getreferrers"></a><strong>getReferrers</strong>(<code>edgeName</code>, <code>edgeType?</code>)',id:"getreferrersedgename-edgetype",level:3},{value:'<a id="tojsonstring"></a><strong>toJSONString</strong>(...<code>args</code>)',id:"tojsonstringargs",level:3},{value:'<a id="tostringnode"></a><strong>toStringNode</strong>()',id:"tostringnode",level:3}],d={toc:s},c="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"IHeapNode")," instance represents a JS heap object in a heap snapshot.\nA heap snapshot is generally a graph where graph nodes are JS heap objects\nand graph edges are JS references among JS heap objects."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"readonly"))," it is not recommended to modify any ",(0,r.kt)("inlineCode",{parentName:"p"},"IHeapNode")," instance"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Examples"),": V8 or hermes heap snapshot can be parsed by the\n",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/modules/heap_analysis_src#getfullheapfromfile"},"getFullHeapFromFile")," API.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import type {IHeapSnapshot, IHeapNode} from '@memlab/core';\nimport {dumpNodeHeapSnapshot} from '@memlab/core';\nimport {getFullHeapFromFile} from '@memlab/heap-analysis';\n\n(async function () {\n  const heapFile = dumpNodeHeapSnapshot();\n  const heap: IHeapSnapshot = await getFullHeapFromFile(heapFile);\n\n  // iterate over each node (heap object)\n  heap.nodes.forEach((node: IHeapNode, i: number) => {\n    // use the heap node APIs here\n    const id = node.id;\n    const type = node.type;\n    // ...\n  });\n})();\n")),(0,r.kt)("h2",{id:"hierarchy"},"Hierarchy"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"IHeapNodeBasic")),(0,r.kt)("p",{parentName:"li"},"\u21b3 ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"IHeapNode"))),(0,r.kt)("p",{parentName:"li"},"\u21b3\u21b3 ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapStringNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapStringNode"))))),(0,r.kt)("h2",{id:"properties"},"Properties"),(0,r.kt)("h3",{id:"-dominatornode-nullableiheapnode"},(0,r.kt)("a",{id:"dominatornode",name:"dominatornode"})," ",(0,r.kt)("strong",{parentName:"h3"},"dominatorNode"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"Nullable"),"<",(0,r.kt)("a",{parentName:"h3",href:"/memlab/docs/api/interfaces/core_src.IHeapNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapNode")),">"),(0,r.kt)("p",null,"get the dominator node of this node. If the dominator node gets released\nthere will be no path from GC to this node, and therefore this node can\nalso be released.\nFor more information on what a dominator node is, please check out\n",(0,r.kt)("a",{parentName:"p",href:"https://developer.chrome.com/docs/devtools/memory-problems/memory-101/#dominators"},"this doc"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1581"},"core/src/lib/Types.ts:1581"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-edge_count-number"},(0,r.kt)("a",{id:"edge\\_count",name:"edge\\_count"})," ",(0,r.kt)("strong",{parentName:"h3"},"edge","_","count"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"number")),(0,r.kt)("p",null,"The total number of outgoing JS references (including engine-internal,\nnative, and JS references)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1535"},"core/src/lib/Types.ts:1535"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-haspathedge-boolean"},(0,r.kt)("a",{id:"haspathedge",name:"haspathedge"})," ",(0,r.kt)("strong",{parentName:"h3"},"hasPathEdge"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"boolean")),(0,r.kt)("p",null,"returns true if the heap node has been set an incoming edge\nwhich leads to the parent node on the shortest path to GC root."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1557"},"core/src/lib/Types.ts:1557"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-id-number"},(0,r.kt)("a",{id:"id",name:"id"})," ",(0,r.kt)("strong",{parentName:"h3"},"id"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"number")),(0,r.kt)("p",null,"unique id of the heap object"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1462"},"core/src/lib/Types.ts:1462"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-isstring-boolean"},(0,r.kt)("a",{id:"isstring",name:"isstring"})," ",(0,r.kt)("strong",{parentName:"h3"},"isString"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"boolean")),(0,r.kt)("p",null,"check if this a string node (normal string node, concatenated string node\nor sliced string node)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1593"},"core/src/lib/Types.ts:1593"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-is_detached-boolean"},(0,r.kt)("a",{id:"is\\_detached",name:"is\\_detached"})," ",(0,r.kt)("strong",{parentName:"h3"},"is","_","detached"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"boolean")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the heap object is a DOM element and the DOM element is detached\nfrom the DOM tree, ",(0,r.kt)("inlineCode",{parentName:"p"},"is_detached")," will be ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the heap object is a React Fiber node and the Fiber node is unmounted\nfrom the React Fiber tree, ",(0,r.kt)("inlineCode",{parentName:"p"},"is_detached")," will be ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),";\notherwise it will be ",(0,r.kt)("inlineCode",{parentName:"p"},"false"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Source"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1517"},"core/src/lib/Types.ts:1517"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-location-nullableiheaplocation"},(0,r.kt)("a",{id:"location",name:"location"})," ",(0,r.kt)("strong",{parentName:"h3"},"location"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"Nullable"),"<",(0,r.kt)("a",{parentName:"h3",href:"/memlab/docs/api/interfaces/core_src.IHeapLocation"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapLocation")),">"),(0,r.kt)("p",null,"source location information of this heap object (if it is recorded by\nthe heap snapshot)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1586"},"core/src/lib/Types.ts:1586"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-name-string"},(0,r.kt)("a",{id:"name",name:"name"})," ",(0,r.kt)("strong",{parentName:"h3"},"name"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"string")),(0,r.kt)("p",null,"this is the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," field associated with the heap object,\nfor JS object instances (type ",(0,r.kt)("inlineCode",{parentName:"p"},"object"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," is the constructor's name\nof the object instance. for ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," is the string value."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1458"},"core/src/lib/Types.ts:1458"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-nodeindex-number"},(0,r.kt)("a",{id:"nodeindex",name:"nodeindex"})," ",(0,r.kt)("strong",{parentName:"h3"},"nodeIndex"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"number")),(0,r.kt)("p",null,"index of this heap object inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"node.snapshot.nodes")," pseudo array"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1566"},"core/src/lib/Types.ts:1566"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-numofreferrers-number"},(0,r.kt)("a",{id:"numofreferrers",name:"numofreferrers"})," ",(0,r.kt)("strong",{parentName:"h3"},"numOfReferrers"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"number")),(0,r.kt)("p",null,"Get the number of all incoming references pointing to this heap object\n(including engine-internal, native, and JS references)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1552"},"core/src/lib/Types.ts:1552"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-pathedge-null--iheapedge"},(0,r.kt)("a",{id:"pathedge",name:"pathedge"})," ",(0,r.kt)("strong",{parentName:"h3"},"pathEdge"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"null")," ","|"," ",(0,r.kt)("a",{parentName:"h3",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge"))),(0,r.kt)("p",null,"The incoming edge which leads to the parent node\non the shortest path to GC root."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1562"},"core/src/lib/Types.ts:1562"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-references-iheapedge"},(0,r.kt)("a",{id:"references",name:"references"})," ",(0,r.kt)("strong",{parentName:"h3"},"references"),": ",(0,r.kt)("a",{parentName:"h3",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),"[]"),(0,r.kt)("p",null,"Get a JS array containing all outgoing JS references from this heap object\n(including engine-internal, native, and JS references)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1542"},"core/src/lib/Types.ts:1542"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-referrers-iheapedge"},(0,r.kt)("a",{id:"referrers",name:"referrers"})," ",(0,r.kt)("strong",{parentName:"h3"},"referrers"),": ",(0,r.kt)("a",{parentName:"h3",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),"[]"),(0,r.kt)("p",null,"Get a JS array containing all incoming JS references pointing to this heap\nobject (including engine-internal, native, and JS references)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1547"},"core/src/lib/Types.ts:1547"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-retainedsize-number"},(0,r.kt)("a",{id:"retainedsize",name:"retainedsize"})," ",(0,r.kt)("strong",{parentName:"h3"},"retainedSize"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"number")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"retained size")," of the heap object (i.e., the total size of memory that\ncould be released if this object is released). For difference between\n",(0,r.kt)("strong",{parentName:"p"},"retained size")," and ",(0,r.kt)("strong",{parentName:"p"},"shallow size"),", check out\n",(0,r.kt)("a",{parentName:"p",href:"https://developer.chrome.com/docs/devtools/memory-problems/memory-101/#object_sizes"},"this doc"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1573"},"core/src/lib/Types.ts:1573"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-self_size-number"},(0,r.kt)("a",{id:"self\\_size",name:"self\\_size"})," ",(0,r.kt)("strong",{parentName:"h3"},"self","_","size"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"number")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"shallow size")," of the heap object (i.e., the size of memory that is held\nby the object itself.). For difference between ",(0,r.kt)("strong",{parentName:"p"},"shallow size")," and\n",(0,r.kt)("strong",{parentName:"p"},"retained size"),", check out\n",(0,r.kt)("a",{parentName:"p",href:"https://developer.chrome.com/docs/devtools/memory-problems/memory-101/#object_sizes"},"this doc"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1530"},"core/src/lib/Types.ts:1530"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-snapshot-iheapsnapshot"},(0,r.kt)("a",{id:"snapshot",name:"snapshot"})," ",(0,r.kt)("strong",{parentName:"h3"},"snapshot"),": ",(0,r.kt)("a",{parentName:"h3",href:"/memlab/docs/api/interfaces/core_src.IHeapSnapshot"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapSnapshot"))),(0,r.kt)("p",null,"get the ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapSnapshot"},"IHeapSnapshot")," containing this heap object"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1509"},"core/src/lib/Types.ts:1509"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"-type-string"},(0,r.kt)("a",{id:"type",name:"type"})," ",(0,r.kt)("strong",{parentName:"h3"},"type"),": ",(0,r.kt)("inlineCode",{parentName:"h3"},"string")),(0,r.kt)("p",null,"the type of the heap node object. All possible types:\nThis is engine-specific, for example all types in V8:\n",(0,r.kt)("inlineCode",{parentName:"p"},"hidden"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"array"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"object"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"code"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"closure"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"regexp"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"native"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"synthetic"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"concatenated string"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"sliced string"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"symbol"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"bigint")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1452"},"core/src/lib/Types.ts:1452"))))),(0,r.kt)("h2",{id:"methods"},"Methods"),(0,r.kt)("h3",{id:"findanyreferencepredicate"},(0,r.kt)("a",{id:"findanyreference"}),(0,r.kt)("strong",{parentName:"h3"},"findAnyReference"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"predicate"),")"),(0,r.kt)("p",null,"executes a provided predicate callback once for each JavaScript reference\nin the hosting node (or outgoing edges from the node) until the predicate\nreturns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"predicate"),": ",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/modules/core_src#predicator"},(0,r.kt)("inlineCode",{parentName:"a"},"Predicator")),"<",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),">"," | the callback for each outgoing JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Nullable"),"<",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),">"," | the first outgoing edge for which the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),",\notherwise returns ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," if no such edge is found.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const reference = node.findAnyReference((edge: IHeapEdge) => {\n  // find the outgoing reference with name \"ref\"\n  return edge.name_or_index === 'ref';\n});\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1662"},"core/src/lib/Types.ts:1662"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"findanyreferrerpredicate"},(0,r.kt)("a",{id:"findanyreferrer"}),(0,r.kt)("strong",{parentName:"h3"},"findAnyReferrer"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"predicate"),")"),(0,r.kt)("p",null,"executes a provided predicate callback once for each JavaScript reference\npointing to the hosting node (or incoming edges to the node) until the\npredicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"predicate"),": ",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/modules/core_src#predicator"},(0,r.kt)("inlineCode",{parentName:"a"},"Predicator")),"<",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),">"," | the callback for each incoming JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Nullable"),"<",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),">"," | the first incoming edge for which the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),",\notherwise returns ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," if no such edge is found.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const referrer = node.findAnyReferrer((edge: IHeapEdge) => {\n  // find the incoming reference with name \"ref\"\n  return edge.name_or_index === 'ref';\n});\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1679"},"core/src/lib/Types.ts:1679"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"findanyreferrernodepredicate"},(0,r.kt)("a",{id:"findanyreferrernode"}),(0,r.kt)("strong",{parentName:"h3"},"findAnyReferrerNode"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"predicate"),")"),(0,r.kt)("p",null,"executes a provided predicate callback once for each JavaScript heap\nobject (heap graph node) pointing to the hosting node\n(or nodes having edges to the hosting node) until the predicate\nreturns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"predicate"),": ",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/modules/core_src#predicator"},(0,r.kt)("inlineCode",{parentName:"a"},"Predicator")),"<",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/interfaces/core_src.IHeapNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapNode")),">"," | the callback for each incoming JavaScript heap object"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Nullable"),"<",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapNode")),">"," | the first referring node for which the predicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),",\notherwise returns ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," if no such node is found.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const referrer = node.findAnyReferrerNode((node: IHeapNode) => {\n  // find the referring node with name \"Parent\"\n  return node.name === 'Parent';\n});\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1697"},"core/src/lib/Types.ts:1697"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"findreferrernodespredicate"},(0,r.kt)("a",{id:"findreferrernodes"}),(0,r.kt)("strong",{parentName:"h3"},"findReferrerNodes"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"predicate"),")"),(0,r.kt)("p",null,"executes a provided predicate callback once for each JavaScript heap\nobject (heap graph node) pointing to the hosting node\n(or nodes having edges to the hosting node)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"predicate"),": ",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/modules/core_src#predicator"},(0,r.kt)("inlineCode",{parentName:"a"},"Predicator")),"<",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/interfaces/core_src.IHeapNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapNode")),">"," | the callback for each referrer nodes"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapNode")),"[] | an array containing all the referrer nodes for which the\npredicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", otherwise returns an empty array if no such\nnode is found.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const referrerNodes = node.findReferrerNodes((node: IHeapNode) => {\n  // find all the referring nodes with name \"Parent\"\n  return node.name === 'Parent';\n});\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1732"},"core/src/lib/Types.ts:1732"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"findreferrerspredicate"},(0,r.kt)("a",{id:"findreferrers"}),(0,r.kt)("strong",{parentName:"h3"},"findReferrers"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"predicate"),")"),(0,r.kt)("p",null,"executes a provided predicate callback once for each JavaScript reference\npointing to the hosting node (or incoming edges to the node)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"predicate"),": ",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/modules/core_src#predicator"},(0,r.kt)("inlineCode",{parentName:"a"},"Predicator")),"<",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),">"," | the callback for each incoming JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),"[] | an array containing all the incoming edges for which the\npredicate returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", otherwise returns an empty array if no such\nedge is found.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const referrers = node.findReferrers((edge: IHeapEdge) => {\n  // find all the incoming references with name \"ref\"\n  return edge.name_or_index === 'ref';\n});\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1714"},"core/src/lib/Types.ts:1714"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"foreachreferencecallback"},(0,r.kt)("a",{id:"foreachreference"}),(0,r.kt)("strong",{parentName:"h3"},"forEachReference"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"callback"),")"),(0,r.kt)("p",null,"executes a provided callback once for each JavaScript reference in the\nhosting node (or outgoing edges from the node)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"callback"),": ",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/modules/core_src#edgeiterationcallback"},(0,r.kt)("inlineCode",{parentName:"a"},"EdgeIterationCallback"))," | the callback for each outgoing JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"void")," | this API returns void")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"node.forEachReference((edge: IHeapEdge) => {\n  // process edge ...\n\n  // if no need to iterate over remaining edges after\n  // the current edge in the node.references list\n  return {stop: true};\n});\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1627"},"core/src/lib/Types.ts:1627"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"foreachreferrercallback"},(0,r.kt)("a",{id:"foreachreferrer"}),(0,r.kt)("strong",{parentName:"h3"},"forEachReferrer"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"callback"),")"),(0,r.kt)("p",null,"executes a provided callback once for each JavaScript reference pointing\nto the hosting node (or incoming edges to the node)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"callback"),": ",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/modules/core_src#edgeiterationcallback"},(0,r.kt)("inlineCode",{parentName:"a"},"EdgeIterationCallback"))," | the callback for each incoming JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"void")," | this API returns void")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"node.forEachReferrer((edge: IHeapEdge) => {\n  // process edge ...\n\n  // if no need to iterate over remaining edges after\n  // the current edge in the node.referrers list\n  return {stop: true};\n});\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1645"},"core/src/lib/Types.ts:1645"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"getanyreferreredgename-edgetype"},(0,r.kt)("a",{id:"getanyreferrer"}),(0,r.kt)("strong",{parentName:"h3"},"getAnyReferrer"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeName"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeType?"),")"),(0,r.kt)("p",null,"Given a JS reference's name and type, this API finds an incoming JS\nreference pointing to the hosting node."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeName"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," ","|"," ",(0,r.kt)("inlineCode",{parentName:"li"},"number")," | the name of the incoming JavaScript reference"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeType?"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," | optional parameter specifying the type of the incoming JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Nullable"),"<",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),">"," | the incoming edge that meets the specification")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// find one of the JS reference named \"ref\" pointing to node\nconst reference = node.getAnyReferrer('ref', 'property');\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1787"},"core/src/lib/Types.ts:1787"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"getanyreferrernodeedgename-edgetype"},(0,r.kt)("a",{id:"getanyreferrernode"}),(0,r.kt)("strong",{parentName:"h3"},"getAnyReferrerNode"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeName"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeType?"),")"),(0,r.kt)("p",null,"Given a JS reference's name and type, this API finds one of the incoming JS\nreferences pointing to the hosting node, and returns the JS heap object\ncontaining the incoming reference."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeName"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," ","|"," ",(0,r.kt)("inlineCode",{parentName:"li"},"number")," | the name of the incoming JavaScript reference"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeType?"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," | optional parameter specifying the type of the incoming JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Nullable"),"<",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapNode")),">"," | the node containing the incoming JS reference that meets\nthe specification")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// find one of the JS heap object with a JS reference\n// named \"ref\" pointing to node\nconst n1 = node.getAnyReferrerNode('ref', 'property');\n// this is equivalent to\nconst n2 = node.getAnyReferrer('ref', 'property')?.fromNode;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1810"},"core/src/lib/Types.ts:1810"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"getreferenceedgename-edgetype"},(0,r.kt)("a",{id:"getreference"}),(0,r.kt)("strong",{parentName:"h3"},"getReference"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeName"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeType?"),")"),(0,r.kt)("p",null,"Given a JS reference's name and type, this API finds an outgoing JS\nreference from the hosting node."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeName"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," ","|"," ",(0,r.kt)("inlineCode",{parentName:"li"},"number")," | the name of the outgoing JavaScript reference"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeType?"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," | optional parameter specifying the type of the outgoing JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Nullable"),"<",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),">"," | the outgoing edge that meets the specification")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// find the internal reference to node's hidden class\nconst reference = node.getReference('map', 'hidden');\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1747"},"core/src/lib/Types.ts:1747"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"getreferencenodeedgename-edgetype"},(0,r.kt)("a",{id:"getreferencenode"}),(0,r.kt)("strong",{parentName:"h3"},"getReferenceNode"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeName"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeType?"),")"),(0,r.kt)("p",null,"Given a JS reference's name and type, this API finds the outgoing JS\nreference from the hosting node, and returns the JS heap object pointed to\nby the outgoing JS reference."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeName"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," ","|"," ",(0,r.kt)("inlineCode",{parentName:"li"},"number")," | the name of the outgoing JavaScript reference"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeType?"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," | optional parameter specifying the type of the outgoing JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Nullable"),"<",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapNode")),">"," | the node pointed to by the outgoing reference that meets\nthe specification")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// find the node's hidden class\nconst hiddenClassNode = node.getReferenceNode('map', 'hidden');\n// this is equivalent to\nconst hiddenClassNode2 = node.getReference('map', 'hidden')?.toNode;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1769"},"core/src/lib/Types.ts:1769"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"getreferrernodesedgename-edgetype"},(0,r.kt)("a",{id:"getreferrernodes"}),(0,r.kt)("strong",{parentName:"h3"},"getReferrerNodes"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeName"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeType?"),")"),(0,r.kt)("p",null,"Given a JS reference's name and type, this API finds all of the incoming JS\nreferences pointing to the hosting node, and returns an array containing\nthe hosting node for each of the incoming JS references."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeName"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," ","|"," ",(0,r.kt)("inlineCode",{parentName:"li"},"number")," | the name of the incoming JavaScript reference"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeType?"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," | optional parameter specifying the type of the incoming JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapNode")),"[] | an array containing the hosting nodes, with each node corresponds\nto each incoming JS reference that meets the specification")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// find all of the JS heap object with a JS reference\n// named \"ref\" pointing to node\nconst nodes1 = node.getReferrerNodes('ref', 'property');\n// this is equivalent to\nconst nodes2 = node.getReferrers('ref', 'property')\n  .map(edge => edge.fromNode);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1850"},"core/src/lib/Types.ts:1850"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"getreferrersedgename-edgetype"},(0,r.kt)("a",{id:"getreferrers"}),(0,r.kt)("strong",{parentName:"h3"},"getReferrers"),"(",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeName"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"edgeType?"),")"),(0,r.kt)("p",null,"Given a JS reference's name and type, this API finds all the incoming JS\nreference pointing to the hosting node."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeName"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," ","|"," ",(0,r.kt)("inlineCode",{parentName:"li"},"number")," | the name of the incoming JavaScript reference"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edgeType?"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," | optional parameter specifying the type of the incoming JavaScript reference"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Returns"),": ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapEdge"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapEdge")),"[] | an array containing all the incoming edges that\nmeet the specification")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Examples"),":"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// find all of of the JS reference named \"ref\" pointing to node\nconst referrers = node.getReferrers('ref', 'property');\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1829"},"core/src/lib/Types.ts:1829"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"tojsonstringargs"},(0,r.kt)("a",{id:"tojsonstring"}),(0,r.kt)("strong",{parentName:"h3"},"toJSONString"),"(...",(0,r.kt)("inlineCode",{parentName:"h3"},"args"),")"),(0,r.kt)("p",null,"convert to a concise readable string output\n(like calling ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON.stringify(node, ...args)"),").\nNote: calling ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON.stringify(node, ...args)")," will not work\nsince the string is too large and not readable."),(0,r.kt)("p",null,"This API does not completely serialize all the information\ncaptured by the hosting object."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameters"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"...args"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"any"),"[]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"string")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1609"},"core/src/lib/Types.ts:1609"))))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"tostringnode"},(0,r.kt)("a",{id:"tostringnode"}),(0,r.kt)("strong",{parentName:"h3"},"toStringNode"),"()"),(0,r.kt)("p",null,"convert to an ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapStringNode"},"IHeapStringNode")," object if this node is a string node.\nThe ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapStringNode"},"IHeapStringNode")," object supports querying the string content\ninside the string node."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Returns"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Nullable"),"<",(0,r.kt)("a",{parentName:"li",href:"/memlab/docs/api/interfaces/core_src.IHeapStringNode"},(0,r.kt)("inlineCode",{parentName:"a"},"IHeapStringNode")),">"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Source"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/memlab/blob/be19325/packages/core/src/lib/Types.ts#L1599"},"core/src/lib/Types.ts:1599"))))))}m.isMDXComponent=!0}}]);