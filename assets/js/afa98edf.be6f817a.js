"use strict";(globalThis.webpackChunkmemlab_website=globalThis.webpackChunkmemlab_website||[]).push([[1603],{2629(e,a,n){n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var t=n(8168),r=(n(6540),n(5680));const l={},i="Interface: ILeakFilter",o={unversionedId:"api/core/src/interfaces/ILeakFilter",id:"api/core/src/interfaces/ILeakFilter",title:"Interface: ILeakFilter",description:"Defined in400",source:"@site/docs/api/core/src/interfaces/ILeakFilter.md",sourceDirName:"api/core/src/interfaces",slug:"/api/core/src/interfaces/ILeakFilter",permalink:"/memlab/docs/api/core/src/interfaces/ILeakFilter",draft:!1,editUrl:"https://github.com/facebook/memlab/blob/main/website/docs/api/core/src/interfaces/ILeakFilter.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Interface: IHeapStringNode",permalink:"/memlab/docs/api/core/src/interfaces/IHeapStringNode"},next:{title:"Interface: IScenario",permalink:"/memlab/docs/api/core/src/interfaces/IScenario"}},s={},c=[{value:"Properties",id:"properties",level:2},{value:"beforeLeakFilter?",id:"beforeleakfilter",level:3},{value:"leakFilter?",id:"leakfilter",level:3},{value:"retainerReferenceFilter?",id:"retainerreferencefilter",level:3}],p={toc:c};function d({components:e,...a}){return(0,r.yg)("wrapper",(0,t.A)({},p,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"interface-ileakfilter"},"Interface: ILeakFilter"),(0,r.yg)("p",null,"Defined in: ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/facebook/memlab/blob/ca9b0621bb05ee96eb3381f9c90b111131038452/packages/core/src/lib/Types.ts#L400"},"core/src/lib/Types.ts:400")),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"ILeakFilter")," interface allows you to define a leak detector and\ncustomize the leak filtering logic in memlab (instead of using the\nbuilt-in leak filters)."),(0,r.yg)("p",null,"Use the leak filter definition in command line interface to filter\nleaks detected from browser interactions"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"memlab run --scenario <SCENARIO FILE> --leak-filter <PATH TO leak-filter.js>\n")),(0,r.yg)("p",null,"If you have already run ",(0,r.yg)("inlineCode",{parentName:"p"},"memlab run")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"memlab snapshot")," which saved\nheap snapshot and other meta data on disk, use the following command\nto filter leaks based on those saved heap snapshots (query the default\ndata location by ",(0,r.yg)("inlineCode",{parentName:"p"},"memlab get-default-work-dir"),")."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"memlab find-leaks --leak-filter <PATH TO leak-filter.js>\n")),(0,r.yg)("p",null,"Here is an example TypeScript file defining a leak filter.\nThe command line interface only accepts compiled JavaScript file.\nYou can also define the leak filter in JavaScript (without the\ntype annotations."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-typescript"},"import {IHeapNode, IHeapSnapshot, HeapNodeIdSet, utils} from '@memlab/core';\n\nfunction initMap(snapshot: IHeapSnapshot): Record<string, number> {\n  const map = Object.create(null);\n  snapshot.nodes.forEach(node => {\n    if (node.type !== 'string') {\n      return;\n    }\n    const str = utils.getStringNodeValue(node);\n    if (str in map) {\n      ++map[str];\n    } else {\n      map[str] = 1;\n    }\n  });\n  return map;\n}\nconst beforeLeakFilter = (snapshot: IHeapSnapshot, _leakedNodeIds: HeapNodeIdSet): void => {\n  map = initMap(snapshot);\n};\n\n// duplicated string with size > 1KB as memory leak\nconst leakFilter = (node: IHeapNode): boolean => {\n  if (node.type !== 'string' || node.retainedSize < 1000) {\n    return false;\n  }\n  const str = utils.getStringNodeValue(node);\n  return map[str] > 1;\n};\n\nexport default {beforeLeakFilter, leakFilter};\n")),(0,r.yg)("h2",{id:"properties"},"Properties"),(0,r.yg)("h3",{id:"beforeleakfilter"},"beforeLeakFilter?"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("inlineCode",{parentName:"p"},"optional")," ",(0,r.yg)("strong",{parentName:"p"},"beforeLeakFilter"),": ",(0,r.yg)("a",{parentName:"p",href:"/memlab/docs/api/core/src/type-aliases/InitLeakFilterCallback"},(0,r.yg)("inlineCode",{parentName:"a"},"InitLeakFilterCallback")))),(0,r.yg)("p",null,"Defined in: ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/facebook/memlab/blob/ca9b0621bb05ee96eb3381f9c90b111131038452/packages/core/src/lib/Types.ts#L428"},"core/src/lib/Types.ts:428")),(0,r.yg)("p",null,"Lifecycle function callback that is invoked initially once before\nthe subsequent ",(0,r.yg)("inlineCode",{parentName:"p"},"leakFilter")," function calls. This callback could\nbe used to initialize some data stores or any one-off\npreprocessings."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Parameters"),":"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"snapshot"),": ",(0,r.yg)("code",null,(0,r.yg)("a",{parentName:"li",href:"/memlab/docs/api/core/src/interfaces/IHeapSnapshot"},"IHeapSnapshot"))," | the final heap\nsnapshot taken after all browser interactions are done.\nCheck out ",(0,r.yg)("a",{parentName:"li",href:"/memlab/docs/api/core/src/interfaces/IHeapSnapshot"},"IHeapSnapshot")," for more APIs that queries the\nheap snapshot."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"leakedNodeIds"),": ",(0,r.yg)("inlineCode",{parentName:"li"},"Set<number>")," | the set of ids of all JS heap objects\nallocated by the ",(0,r.yg)("inlineCode",{parentName:"li"},"action")," call but not released after the ",(0,r.yg)("inlineCode",{parentName:"li"},"back")," call\nin browser."))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Examples"),":"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"module.exports = {\n  beforeLeakFilter: (snapshot, leakedNodeIds) {\n    // initialize some data stores\n  },\n  leakFilter(node, snapshot, leakedNodeIds) {\n    // use the data stores\n  },\n};\n")),(0,r.yg)("hr",null),(0,r.yg)("h3",{id:"leakfilter"},"leakFilter?"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("inlineCode",{parentName:"p"},"optional")," ",(0,r.yg)("strong",{parentName:"p"},"leakFilter"),": ",(0,r.yg)("a",{parentName:"p",href:"/memlab/docs/api/core/src/type-aliases/LeakFilterCallback"},(0,r.yg)("inlineCode",{parentName:"a"},"LeakFilterCallback")))),(0,r.yg)("p",null,"Defined in: ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/facebook/memlab/blob/ca9b0621bb05ee96eb3381f9c90b111131038452/packages/core/src/lib/Types.ts#L480"},"core/src/lib/Types.ts:480")),(0,r.yg)("p",null,"This callback defines how you want to filter out the\nleaked objects. The callback is called for every node (JS heap\nobject in browser) allocated by the ",(0,r.yg)("inlineCode",{parentName:"p"},"action")," callback, but not\nreleased after the ",(0,r.yg)("inlineCode",{parentName:"p"},"back")," callback. Those objects could be caches\nthat are retained in memory on purpose, or they are memory leaks."),(0,r.yg)("p",null,"This optional callback allows you to define your own algorithm\nto cherry pick memory leaks for specific JS program under test."),(0,r.yg)("p",null,"If this optional callback is not defined, memlab will use its\nbuilt-in leak filter, which considers detached DOM elements\nand unmounted Fiber nodes (detached from React Fiber tree) as\nmemory leaks."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Parameters"),":"),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"node"),": ",(0,r.yg)("code",null,(0,r.yg)("a",{parentName:"li",href:"/memlab/docs/api/core/src/interfaces/IHeapNode"},"IHeapNode"))," | the heap object\nallocated but not released. This filter callback will be applied\nto each node allocated but not released in the heap snapshot."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"snapshot"),": ",(0,r.yg)("code",null,(0,r.yg)("a",{parentName:"li",href:"/memlab/docs/api/core/src/interfaces/IHeapSnapshot"},"IHeapSnapshot"))," | the final heap\nsnapshot taken after all browser interactions are done.\nCheck out ",(0,r.yg)("a",{parentName:"li",href:"/memlab/docs/api/core/src/interfaces/IHeapSnapshot"},"IHeapSnapshot")," for more APIs that queries the\nheap snapshot."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"leakedNodeIds"),": ",(0,r.yg)("inlineCode",{parentName:"li"},"Set<number>")," | the set of ids of all JS heap objects\nallocated by the ",(0,r.yg)("inlineCode",{parentName:"li"},"action")," call but not released after the ",(0,r.yg)("inlineCode",{parentName:"li"},"back")," call\nin browser."))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Returns"),": the boolean value indicating whether the given node in\nthe snapshot should be considered as leaked.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Examples"),":"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"// save as leak-filter.js\nmodule.exports = {\n  leakFilter(node, snapshot, leakedNodeIds) {\n    // any unreleased node (JS heap object) with 1MB+\n    // retained size is considered a memory leak\n    return node.retainedSize > 1000000;\n  },\n};\n")),(0,r.yg)("p",null,"Use the leak filter definition in command line interface:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"memlab find-leaks --leak-filter <PATH TO leak-filter.js>\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"memlab run --scenario <SCENARIO FILE> --leak-filter <PATH TO leak-filter.js>\n")),(0,r.yg)("hr",null),(0,r.yg)("h3",{id:"retainerreferencefilter"},"retainerReferenceFilter?"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("inlineCode",{parentName:"p"},"optional")," ",(0,r.yg)("strong",{parentName:"p"},"retainerReferenceFilter"),": ",(0,r.yg)("a",{parentName:"p",href:"/memlab/docs/api/core/src/type-aliases/ReferenceFilterCallback"},(0,r.yg)("inlineCode",{parentName:"a"},"ReferenceFilterCallback")))),(0,r.yg)("p",null,"Defined in: ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/facebook/memlab/blob/ca9b0621bb05ee96eb3381f9c90b111131038452/packages/core/src/lib/Types.ts#L543"},"core/src/lib/Types.ts:543")),(0,r.yg)("p",null,"Callback that can be used to define a logic to decide whether\na reference should be considered as part of the retainer trace.\nThe callback is called for every reference (edge) in the heap snapshot."),(0,r.yg)("p",null,"For concrete examples, check out ",(0,r.yg)("a",{parentName:"p",href:"#leakfilter"},"leakFilter"),"."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Parameters"),":"),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"edge")," : ",(0,r.yg)("code",null,(0,r.yg)("a",{parentName:"li",href:"/memlab/docs/api/core/src/interfaces/IHeapEdge"},"IHeapEdge"))," | the reference (edge)\nthat is considered for calcualting the retainer trace"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"snapshot"),": ",(0,r.yg)("code",null,(0,r.yg)("a",{parentName:"li",href:"/memlab/docs/api/core/src/interfaces/IHeapSnapshot"},"IHeapSnapshot"))," | the final heap\nsnapshot taken after all browser interactions are done.\nCheck out ",(0,r.yg)("a",{parentName:"li",href:"/memlab/docs/api/core/src/interfaces/IHeapSnapshot"},"IHeapSnapshot")," for more APIs that queries the\nheap snapshot."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"isReferenceUsedByDefault"),": ",(0,r.yg)("inlineCode",{parentName:"li"},"boolean")," | MemLab has its own default\nlogic for whether a reference should be considered as part of the\nretainer trace, if this parameter is true, it means MemLab will\nconsider this reference when calculating the retainer trace."))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Returns"),": the value indicating whether the given reference should be\nconsidered when calculating the retainer trace. Note that when this\ncallback returns true, the reference will only be considered as a candidate\nfor retainer trace, so it may or may not be included in the retainer trace;\nhowever, if this callback returns false, the reference will be excluded."))),(0,r.yg)("p",null,"Note that by excluding a dominator reference of an object (i.e., an edge\nthat must be traveled through to reach the heap object from GC roots),\nthe object will be considered as unreachable in the heap graph; and\ntherefore, the reference and heap object will not be included in the\nretainer trace detection and retainer size calculation."),(0,r.yg)("p",null,"Please also be aware that some edges like self-referencing edges,\nJS engine's internal edges, and hidden edges should not be considered\nas part of the retainer trace. These edges could make the retainer trace\nunncessarily complex and cause confusion. ",(0,r.yg)("inlineCode",{parentName:"p"},"isReferenceUsedByDefault")," will\nbe ",(0,r.yg)("inlineCode",{parentName:"p"},"false")," for these types of edges."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Examples"),":")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"// save as leak-filter.js\nmodule.exports = {\n  retainerReferenceFilter(edge, _snapshot, _isReferenceUsedByDefault) {\n    // exclude react fiber references\n    if (edge.name_or_index.toString().startsWith('__reactFiber$')) {\n      return false;\n    }\n    // exclude other references here\n    // ...\n    return true;\n  }\n};\n")),(0,r.yg)("p",null,"Use the leak filter definition in command line interface:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"memlab find-leaks --leak-filter <PATH TO leak-filter.js>\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"memlab run --scenario <SCENARIO FILE> --leak-filter <PATH TO leak-filter.js>\n")))}d.isMDXComponent=!0},5680(e,a,n){n.d(a,{xA:()=>p,yg:()=>g});var t=n(6540);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function l(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),n.push.apply(n,t)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?l(Object(n),!0).forEach(function(a){r(e,a,n[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))})}return e}function o(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=t.createContext({}),c=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},p=function(e){var a=c(e.components);return t.createElement(s.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},m=t.forwardRef(function(e,a){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=c(n),g=r,u=m["".concat(s,".").concat(g)]||m[g]||d[g]||l;return n?t.createElement(u,i(i({ref:a},p),{},{components:n})):t.createElement(u,i({ref:a},p))});function g(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);