"use strict";(self.webpackChunkmemlab_website=self.webpackChunkmemlab_website||[]).push([[5719],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),m=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},b=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=m(a),b=r,u=p["".concat(l,".").concat(b)]||p[b]||d[b]||o;return a?n.createElement(u,i(i({ref:t},c),{},{components:a})):n.createElement(u,i({ref:t},c))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=b;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var m=2;m<o;m++)i[m]=a[m];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}b.displayName="MDXCreateElement"},943:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>m});var n=a(7462),r=(a(7294),a(3905));const o={},i="How memlab Works",s={unversionedId:"how-memlab-works",id:"how-memlab-works",title:"How memlab Works",description:"In a nutshell, memlab starts a headless Chrome browser, interacts with the page,",source:"@site/docs/how-memlab-works.md",sourceDirName:".",slug:"/how-memlab-works",permalink:"/memlab/docs/how-memlab-works",draft:!1,editUrl:"https://github.com/facebook/memlab/blob/main/website/docs/how-memlab-works.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Set up Continuous Test",permalink:"/memlab/docs/guides/integration-and-file-structure"},next:{title:"Table of contents",permalink:"/memlab/docs/api/"}},l={},m=[{value:"1. Browser Interaction",id:"1-browser-interaction",level:2},{value:"2. Heap Analysis",id:"2-heap-analysis",level:2},{value:"3. Retainer Traces for Memory Leaks",id:"3-retainer-traces-for-memory-leaks",level:2}],c={toc:m},p="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-memlab-works"},"How memlab Works"),(0,r.kt)("p",null,"In a nutshell, memlab starts a headless Chrome browser, interacts with the page,\ntakes heap snapshots, and finds memory leaks by parsing, diffing, and analyzing\nheap snapshots."),(0,r.kt)("h2",{id:"1-browser-interaction"},"1. Browser Interaction"),(0,r.kt)("p",null,"For example, if we want to find memory leaks triggered by some interactions\nin a web app on a target page (",(0,r.kt)("inlineCode",{parentName:"p"},"TP"),"), memlab visits the web page in the\nfollowing order:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Visit a different page - let's call it baseline page ",(0,r.kt)("inlineCode",{parentName:"li"},"BP")," and take a\nheap snapshot named ",(0,r.kt)("inlineCode",{parentName:"li"},"SBP"),(0,r.kt)("em",{parentName:"li"},"(the baseline page is specified by the ",(0,r.kt)("strong",{parentName:"em"},(0,r.kt)("inlineCode",{parentName:"strong"},"url")),"\ncallback in ",(0,r.kt)("a",{parentName:"em",href:"/memlab/docs/api/interfaces/core_src.IScenario"},"test scenario"),")")),(0,r.kt)("li",{parentName:"ul"},"Visit the target page ",(0,r.kt)("inlineCode",{parentName:"li"},"TP")," and take another heap snapshot ",(0,r.kt)("inlineCode",{parentName:"li"},"STP"),(0,r.kt)("em",{parentName:"li"},"(the target interactions are specified by the ",(0,r.kt)("strong",{parentName:"em"},(0,r.kt)("inlineCode",{parentName:"strong"},"action")),"\ncallback in ",(0,r.kt)("a",{parentName:"em",href:"/memlab/docs/api/interfaces/core_src.IScenario"},"test scenario"),")")),(0,r.kt)("li",{parentName:"ul"},"Finally, come back to the baseline page (",(0,r.kt)("inlineCode",{parentName:"li"},"BP"),"), and take the last\nheap snapshot ",(0,r.kt)("inlineCode",{parentName:"li"},"SBP'"),". With these heap snapshots, memlab finds memory\nleaks as explained in the next section.\n",(0,r.kt)("em",{parentName:"li"},"(the final page is specified by the ",(0,r.kt)("strong",{parentName:"em"},(0,r.kt)("inlineCode",{parentName:"strong"},"back")),"\ncallback in ",(0,r.kt)("a",{parentName:"em",href:"/memlab/docs/api/interfaces/core_src.IScenario"},"test scenario"),")"))),(0,r.kt)("h2",{id:"2-heap-analysis"},"2. Heap Analysis"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Snapshot decoding"),": memlab decodes V8 (or hermes) heap snapshots and\nprovides ",(0,r.kt)("a",{parentName:"p",href:"/memlab/docs/api/interfaces/core_src.IHeapSnapshot"},"APIs")," that allows\nquerying JavaScript heap."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Leak detection"),": A superset of objects leaked from the target page can\nbe derived as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-math"},"(STP \\ SBP) \u2229 SBP'\n")),(0,r.kt)("p",null,"MemLab first gets a set of allocated objects in ",(0,r.kt)("inlineCode",{parentName:"p"},"TP")," (target interaction)\nby excluding ",(0,r.kt)("inlineCode",{parentName:"p"},"SBP"),"'s objects (object allocated from the baseline page)\nfrom ",(0,r.kt)("inlineCode",{parentName:"p"},"STP")," (target heap snapshot)."),(0,r.kt)("p",null,"Then it takes an intersection with objects in ",(0,r.kt)("inlineCode",{parentName:"p"},"SBP'")," (object remaining on the\nfinal page) to get objects that:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"are allocated from target interaction (",(0,r.kt)("inlineCode",{parentName:"li"},"TP"),")"),(0,r.kt)("li",{parentName:"ol"},"but remain alive after memlab navigates from it.")),(0,r.kt)("p",null,"The built-in leak detectors use domain-specific heuristics to further refine\nthe list of leaked objects (e.g., detached DOM elements, error stack trace, etc.\nmemlab also identifies React Fiber tree and detects unmounted Fiber nodes)."),(0,r.kt)("h2",{id:"3-retainer-traces-for-memory-leaks"},"3. Retainer Traces for Memory Leaks"),(0,r.kt)("p",null,"memlab generates retainer traces from GC roots to leaked objects. Sometimes\ncertain interactions could trigger thousands of leaked objects, it would be\noverwhelming to show all the retainer traces. memlab clusters all retainer\ntraces and only shows one retainer trace for each memory leak cluster."))}d.isMDXComponent=!0}}]);